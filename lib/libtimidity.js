var Libtimidity = (() => {
  var _scriptDir =
    typeof document !== "undefined" && document.currentScript
      ? document.currentScript.src
      : undefined;

  return function (Libtimidity) {
    Libtimidity = Libtimidity || {};

    var Module = typeof Libtimidity != "undefined" ? Libtimidity : {};
    var readyPromiseResolve, readyPromiseReject;
    Module["ready"] = new Promise(function (resolve, reject) {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    var moduleOverrides = Object.assign({}, Module);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var ENVIRONMENT_IS_WEB = true;
    var ENVIRONMENT_IS_WORKER = false;
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    var read_, readAsync, readBinary, setWindowTitle;
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }
      if (scriptDirectory.indexOf("blob:") !== 0) {
        scriptDirectory = scriptDirectory.substr(
          0,
          scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1
        );
      } else {
        scriptDirectory = "";
      }
      {
        read_ = (url) => {
          try {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          } catch (err) {
            var data = tryParseAsDataURI(url);
            if (data) {
              return intArrayToString(data);
            }
            throw err;
          }
        };
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            try {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            } catch (err) {
              var data = tryParseAsDataURI(url);
              if (data) {
                return data;
              }
              throw err;
            }
          };
        }
        readAsync = (url, onload, onerror) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = () => {
            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
              onload(xhr.response);
              return;
            }
            var data = tryParseAsDataURI(url);
            if (data) {
              onload(data.buffer);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }
      setWindowTitle = (title) => (document.title = title);
    } else {
    }
    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.warn.bind(console);
    Object.assign(Module, moduleOverrides);
    moduleOverrides = null;
    if (Module["arguments"]) arguments_ = Module["arguments"];
    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
    if (Module["quit"]) quit_ = Module["quit"];
    var wasmBinary;
    if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
    var noExitRuntime = Module["noExitRuntime"] || true;
    if (typeof WebAssembly != "object") {
      abort("no native wasm support detected");
    }
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }
    var UTF8Decoder =
      typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;
    function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode(((u0 & 31) << 6) | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          u0 =
            ((u0 & 7) << 18) |
            (u1 << 12) |
            (u2 << 6) |
            (heapOrArray[idx++] & 63);
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
        }
      }
      return str;
    }
    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }
    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0)) return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);
          u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);
        }
        if (u <= 127) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 192 | (u >> 6);
          heap[outIdx++] = 128 | (u & 63);
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 224 | (u >> 12);
          heap[outIdx++] = 128 | ((u >> 6) & 63);
          heap[outIdx++] = 128 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 240 | (u >> 18);
          heap[outIdx++] = 128 | ((u >> 12) & 63);
          heap[outIdx++] = 128 | ((u >> 6) & 63);
          heap[outIdx++] = 128 | (u & 63);
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }
    function lengthBytesUTF8(str) {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var c = str.charCodeAt(i);
        if (c <= 127) {
          len++;
        } else if (c <= 2047) {
          len += 2;
        } else if (c >= 55296 && c <= 57343) {
          len += 4;
          ++i;
        } else {
          len += 3;
        }
      }
      return len;
    }
    var buffer,
      HEAP8,
      HEAPU8,
      HEAP16,
      HEAPU16,
      HEAP32,
      HEAPU32,
      HEAPF32,
      HEAPF64;
    function updateGlobalBufferAndViews(buf) {
      buffer = buf;
      Module["HEAP8"] = HEAP8 = new Int8Array(buf);
      Module["HEAP16"] = HEAP16 = new Int16Array(buf);
      Module["HEAP32"] = HEAP32 = new Int32Array(buf);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
    }
    var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
    var wasmTable;
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function")
          Module["preRun"] = [Module["preRun"]];
        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true;
      if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
      FS.ignorePermissions = false;
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function")
          Module["postRun"] = [Module["postRun"]];
        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id) {
      return id;
    }
    function addRunDependency(id) {
      runDependencies++;
      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
    }
    function removeRunDependency(id) {
      runDependencies--;
      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
      }
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      what += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }
    var wasmBinaryFile;
    wasmBinaryFile =
      "data:application/octet-stream;base64,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QQJrQQA6AAAgAUEHSQ0AIABBADoAAyACQQRrQQA6AAAgAUEJSQ0AIABBACAAa0EDcSICaiIAQQA2AgAgACABIAJrQXxxIgJqIgFBBGtBADYCACACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC+cCAQd/IwBBIGsiBSQAAn8CQCAAIAFB7AFsaiIEQeANaigCACICRQ0AIARB2A1qIgYgBigCACACaiIHNgIAIARB3A1qKAIAIQMCQCACQQBIBEAgAyAHTg0BDAILIAMgB0oNAQsgBiADNgIAQQEgACABEBkNARoLIARB8A1qKAIAIgYEQCAAIAFB7AFsaiIEQcQNaigCAC0AZEEHdCEDAkAgBEHkDWoiBygCACICRQ0AIARB6A1qIgggCCgCACACaiICNgIAIAJBgIAETgRAIAdBADYCAAwBCyACIANsQRB1IQMLIARB7A1qIgIgAigCACAGaiICNgIAIAVBEGogAkEFdbdEGC1EVPsheT+iEC1EAAAAAAAA8D+gIAO3ohAYIAUgBSkDECAFKQMYQoCAgICAgID3v38QFCAEQYwOaiAFKQMAIAUpAwgQE0MAAIA/kjgCAAsgACABEA5BAAshAyAFQSBqJAAgAwv3LQELfyMAQRBrIgskAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEH0AU0EQEHMzwAoAgAiBUEQIABBC2pBeHEgAEELSRsiBkEDdiIAdiIBQQNxBEACQCABQX9zQQFxIABqIgJBA3QiAUH0zwBqIgAgAUH8zwBqKAIAIgEoAggiA0YEQEHMzwAgBUF+IAJ3cTYCAAwBCyADIAA2AgwgACADNgIICyABQQhqIQAgASACQQN0IgJBA3I2AgQgASACaiIBIAEoAgRBAXI2AgQMDAsgBkHUzwAoAgAiB00NASABBEACQEECIAB0IgJBACACa3IgASAAdHEiAEEAIABrcUEBayIAIABB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AzYCGAsCQCAEQQ9NBEAgAiAEIAZqIgBBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQMAQsgAiAGQQNyNgIEIAIgBmoiAyAEQQFyNgIEIAMgBGogBDYCACAHBEAgB0F4cUH0zwBqIQBB4M8AKAIAIQECf0EBIAdBA3Z0IgYgBXFFBEBBzM8AIAUgBnI2AgAgAAwBCyAAKAIICyEFIAAgATYCCCAFIAE2AgwgASAANgIMIAEgBTYCCAtB4M8AIAM2AgBB1M8AIAQ2AgALIAJBCGohAAsgC0EQaiQAIAALtAMCA38BfiMAQSBrIgMkAAJAIAFC////////////AIMiBUKAgICAgIDAwD99IAVCgICAgICAwL/AAH1UBEAgAUIZiKchBCAAUCABQv///w+DIgVCgICACFQgBUKAgIAIURtFBEAgBEGBgICABGohAgwCCyAEQYCAgIAEaiECIAAgBUKAgIAIhYRCAFINASACIARBAXFqIQIMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQhmIp0H///8BcUGAgID+B3IhAgwBC0GAgID8ByECIAVC////////v7/AAFYNAEEAIQIgBUIwiKciBEGR/gBJDQAgA0EQaiAAIAFC////////P4NCgICAgICAwACEIgUgBEGB/gBrEBUgAyAAIAVBgf8AIARrECIgAykDCCIAQhmIpyECIAMpAwAgAykDECADKQMYhEIAUq2EIgVQIABC////D4MiAEKAgIAIVCAAQoCAgAhRG0UEQCACQQFqIQIMAQsgBSAAQoCAgAiFhEIAUg0AIAJBAXEgAmohAgsgA0EgaiQAIAIgAUIgiKdBgICAgHhxcr4LswoCBX8QfiMAQeAAayIEJAAgA0L///////8/gyELIAIgA4VCgICAgICAgICAf4MhCSACQv///////z+DIgxCIIghDwJAAkAgA0IwiKdB//8BcSIGQf//AWtBgYB+SyACQjCIp0H//wFxIghB//8Ba0GCgH5PcQ0AIAFQIAJC////////////AIMiCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQkMAgsgA0L///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFFyRQRAIANCgICAgICAIIQhCUIAIQEMAgsgASAKQoCAgICAgMD//wCFhFAEQCACUARAQoCAgICAgOD//wAhCUIAIQEMAwsgCUKAgICAgIDA//8AhCEJQgAhAQwCCyACQoCAgICAgMD//wCFUARAIAEgCoQhAkIAIQEgAlAEQEKAgICAgIDg//8AIQkMAwsgCUKAgICAgIDA//8AhCEJDAILIAEgCoRQBEBCACEBDAILIAJQBEBCACEBDAILIApC////////P1gEQCAEQdAAaiABIAwgASAMIAxQIgUbeSAFQQZ0rXynIgVBD2sQFUEQIAVrIQUgBCkDWCIMQiCIIQ8gBCkDUCEBCyACQv///////z9WDQAgBEFAa0IAIAtCACALIAtQIgcbeSAHQQZ0rXynIgdBD2sQFSAFIAdrQRBqIQUgBCkDSCELIAQpA0AhDQsgDUIPhiIKQoCA/v8PgyICIAFCIIgiA34iESAKQiCIIg4gAUL/////D4MiAX58IhBCIIYiEiABIAJ+fCIKIBJUrSACIAxC/////w+DIgx+IhUgAyAOfnwiEiALQg+GIhMgDUIxiIRC/////w+DIgsgAX58IhQgECARVK1CIIYgEEIgiIR8IhAgAiAPQoCABIQiDX4iFiAMIA5+fCIPIBNCIIhCgICAgAiEIgIgAX58IhEgAyALfnwiE0IghnwiF3whASAGIAhqIAVqQf//AGshBQJAIAIgA34iGCANIA5+fCIDIBhUrSADIAMgCyAMfnwiDlatfCACIA1+fCAOIA4gEiAVVK0gEiAUVq18fCIDVq18IAsgDX4iCyACIAx+fCICIAtUrUIghiACQiCIhHwgAyACQiCGfCICIANUrXwgAiACIBEgE1atIA8gFlStIA8gEVatfHxCIIYgE0IgiIR8IgNWrXwgAyADIBAgFFStIBAgF1atfHwiAlatfCIDQoCAgICAgMAAg1BFBEAgBUEBaiEFDAELIApCP4ghCyADQgGGIAJCP4iEIQMgAkIBhiABQj+IhCECIApCAYYhCiALIAFCAYaEIQELIAVB//8BTgRAIAlCgICAgICAwP//AIQhCUIAIQEMAQsCfiAFQQBMBEBBASAFayIGQYABTwRAQgAhAQwDCyAEQTBqIAogASAFQf8AaiIFEBUgBEEgaiACIAMgBRAVIARBEGogCiABIAYQIiAEIAIgAyAGECIgBCkDMCAE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AhQgACgCgGYiAkEASgRAQQAhAQNAIAAgAUHsAWxqQcANai0AAARAIAAgARAdIAAgARAOIAAoAoBmIQILIAFBAWoiASACSA0ACwsLyxcDDX8BfAF9IAAoAgRFBEBBAA8LIAIgACgCECIDbiIKQQBKBH8gACgCpGYiCyAKaiEIIAshAwNAIAMgACgCnGYiAigCACIGTgRAA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAi0ABUEBaw5jAAECBQYJBwQIEQMMCgsNEREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREOEQsgACgCgGYhBiACLQAHRQRAIAZFDREDQAJAIAAgBkEBayIGQewBbGoiA0HADWoiBC0AAEEBRw0AIANBwQ1qLQAAIgUgAi0ABEcNACADQcINai0AACACLQAGRw0AIAAgBUEobGpBzAhqKAIABEAgBEECOgAADBQLIANBxA1qKAIALQBmQcAAcUUNESADQZwPakEDNgIAIARBAzoAACAAIAYQGRogACAGEA4MEwsgBg0ACwwRCwJAIAZFDQBBfyEEIAYhAwNAIAQhBSADQQFrIgMhBCAAIANB7AFsaiIHQcANaiIJLQAABEACQCAHQcENai0AACIEIAItAARHDQAgB0HCDWotAAAgAi0ABkcEQCAAIARBKGxqQdwIaigCAEUNAQsgCUEEOgAACyAFIQQLIAMNAAtBfyEDIARBf0cNEEH/////ByEFA0ACQAJAIAAgBkEBayIGQewBbGoiB0HADWotAABBAWsOBAEAAAEACyAHQfwNaigCACEEIAdBqA9qKAIARQRAIAdBgA5qKAIAIgcgBCAEIAdIGyEECyAEIAUgBCAFSCIEGyEFIAYgAyAEGyEDCyAGDQALIANBf0YNACAAIAAoApBmQQFqNgKQZiAAIANB7AFsakHADWpBADoAACAAIAIgAxA4DBELIAAgACgCjGZBAWo2AoxmDBALIAAoAoBmIgNFDQ8DQAJAIAAgA0EBayIDQewBbGoiBEHADWoiBS0AAEEBRw0AIARBwQ1qLQAAIgYgAi0ABEcNACAEQcINai0AACACLQAGRw0AIAAgBkEobGpBzAhq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aiEAIAFBBGohASACQQFrBSACCyEDIAJBAUYNAANAIABB//8BIAEoAgAiAkENdSIEQYCAfiAEQYCAfkobIAJB/////wBKGyICQQh0IAJBgP4DcUEIdnI7AQAgAEH//wEgASgCBCICQQ11IgRBgIB+IARBgIB+ShsgAkH/////AEobIgJBCHQgAkGA/gNxQQh2cjsBAiAAQQRqIQAgAUEIaiEBIANBAmsiAw0ACwsL1wEBAn8CQCACRQ0AIAJBAXEEfyAAQX8gASgCACIEQQ11IgNBgIB+IANBgIB+ShtBgIACcyAEQf////8AShs7AQAgAEECaiEAIAFBBGohASACQQFrBSACCyEEIAJBAUYNAANAIABBfyABKAIAIgJBDXUiA0GAgH4gA0GAgH5KG0GAgAJzIAJB/////wBKGzsBACAAQX8gASgCBCICQQ11IgNBgIB+IANBgIB+ShtBgIACcyACQf////8AShs7AQIgAEEEaiEAIAFBCGohASAEQQJrIgQNAAsLC84BAQJ/AkAgAkUNACACQQFxBH8gAEH//wEgASgCACIEQQ11IgNBgIB+IANBgIB+ShsgBEH/////AEobOwEAIABBAmohACABQQRqIQEgAkEBawUgAgshBCACQQFGDQADQCAAQf//ASABKAIAIgJBDXUiA0GAgH4gA0GAgH5KGyACQf////8AShs7AQAgAEH//wEgASgCBCICQQ11IgNBgIB+IANBgIB+ShsgAkH/////AEobOwECIABBBGohACABQQhqIQEgBEECayIEDQALCwvOAQECfwJAIAJFDQAgAkEBcQR/IABBfyABKAIAIgRBFXUiA0GAfyADQYB/ShtBgAFzIARB/////wBKGzoAACAAQQFqIQAgAUEEaiEBIAJBAWsFIAILIQQgAkEBRg0AA0AgAEF/IAEoAgAiAkEVdSIDQYB/IANBgH9KG0GAAXMgAkH/////AEobOgAAIABBfyABKAIEIgJBFXUiA0GAfyADQYB/ShtBgAFzIAJB/////wBKGzoAASAAQQJqIQAgAUEIaiEBIARBAmsiBA0ACwsLxQEBAn8CQCACRQ0AIAJBAXEEfyAAQf8AIAEoAgAiBEEVdSIDQYB/IANBgH9KGyAEQf////8AShs6AAAgAEEBaiEAIAFBBGohASACQQFrBSACCyEEIAJBAUYNAANAIABB/wAgASgCACICQRV1IgNBgH8gA0GAf0obIAJB/////wBKGzoAACAAQf8AIAEoAgQiAkEVdSIDQYB/IANBgH9KGyACQf////8AShs6AAEgAEECaiEAIAFBCGohASAEQQJrIgQNAAsLCwu9PAMAQYAIC+c7IAmgAEhUVFBwcm94eQBGVFBwcm94eQBlbnYAdGltZW91dABvcHQAc291bmRmb250AGRlZmF1bHQAcmlnaHQAbGVmdABjb3B5ZHJ1bXNldAAucGF0AGRpcgBjZW50ZXIAbWFpbGFkZHIAbG9vcABhbXAAc3RyaXAAa2VlcABtYXAAI2V4dGVuc2lvbgBhbHRhc3NpZ24AcGFuAGNvbW0AdGFpbABjb3B5YmFuawB0aW1pZGl0eS5jZmcAdW5kZWYAbm90ZQBwcm9nYmFzZQBzb3VyY2UAcmIAcndhAD8/Pz8/PwBHRjFQQVRDSDExMABJRCMwMDAwMDIAR0YxUEFUQ0gxMDAASUQjMDAwMDAyAADwHwAA1iEAANkjAAD7JQAAPSgAAKEqAAAqLQAA2i8AALIyAAC2NQAA6DgAAEo8AADgPwAArEMAALJHAAD1SwAAelAAAENVAABVWgAAtF8AAGVlAABsawAAz3EAAJR4AAC/fwAAWIcAAGSPAADrlwAA86AAAIaqAACptAAAZ78AAMnKAADY1gAAnuMAACfxAAB+/wAAsA4BAMgeAQDWLwEA50EBAAtVAQBTaQEAz34BAJKVAQCwrQEAPccBAE/iAQD9/gEAXx0CAJA9AgCrXwIAzoMCABaqAgCl0gIAnv0CACQrAwBgWwMAeo4DAJ7EAwD6/QMAvzoEACF7BABXvwQAnAcFACxUBQBKpQUAO/sFAElWBgDAtgYA9BwHADuJBwDz+wcAfXUIAEL2CACufgkANw8KAFioCgCVSgsAd/YLAJGsDACAbQ0A6DkOAHcSDwDm9w8A++oQAIPsEQBc/RIAbh4UALFQFQAqlRYA7uwXACNZGQAA2xoAz3McAO0kHgDN7x8A9dUhAAbZIwC4+iUA3DwoAGKhKgBTKi0A29kvAEayMgAAtjUAnuc4ANpJPACZ3z8A6qtDAAyyRwBw9UsAuXlQAMRCVQCnVFoAt7NfAItkZQAAbGsAPM9xALWTeAAyv38A1FeHABlkjwDf6pcAcvOgAIeFqgBOqbQAbme/AAAAAAAAAJA/S781QVqIkD/xLr2CPhWRP/nGM3PTppE/wm3dCkE9kj89wp2WsNiSP+jqTsNMeZM/zAZ5qUEflD+sd23ZvMqUP4hYyWfte5U/mo9i+gMzlj9ZCKPVMvCWP0XAVeqts5c/YnDp46p9mD/yvSw3YU6ZP739hzEKJpo/VLi4COEEmz/oQBPrIuubP2XVThAP2Zw/UuTgyubOnT9uPOyZ7cyeP5USyTtp058/J3qV4FBxoD+B9HTQcP2gPycYOuY6jqE/Sh134tYjoj8yVIPYbb6iP4knwjkqXqM/wzlK4TcDpD/h0O8fxK2kP43etcj9XaU/Pg+pPRUUpj/fZyh9PNCmP5sXny+nkqc/lEKztYpbqD9Qqu02HiupP+053rCaAao/aJ7BBjvfqj+2NqwRPMSrP/jLPrHcsKw/Majp3F2lrT9zyMK1AqKuP2wQ9JgQp68/TkdjmWdasD/VBShJxOWwPxEm5J7EdbE/uczFI5AKsj+AK+ixT6SyP5jMin8tQ7M/eXOoKlXnsz+BwfDE85C0PxPoJ+A3QLU/8s3vmlH1tT95Kv6tcrC2Pz43w3nOcbc/lreEFJo5uD98NfFYDAi5Pyh0L/Vd3bk/6jpuesm5uj8Avvhsi527P7kP1FTiiLw/dynqzg58vT9aQ8eeU3e+P3FZ7sD1er8/WvPkPp5DwD+GBJ++OM7AP/q2cG1wXcE/hkpxnWzxwT+eks/vVYrCP/Gg+V9WKMM/NYAjT5nLwz8IKTCQS3TEPzT2/3ObIsU/PPkn1rjWxT/nrBUq1ZDGP2ehoogjUcc/QNwbvtgXyD/9xcBYK+XIP6mgvbdTuck/l6OlGoyUyj9w/HCxEHfLP4QZA60fYcw/xMY9UPlSzT+BzaUB4EzOPwzvnV0YT88/s52epPQs0D8Y+OICzrbQP90bYSI+RdE/8SZmHmzY0T+434NfgHDSP4/UqKakDdM/9gaXGASw0z8ZSLxJy1fUPyaHb0ooBdU/6m2Ws0q41T9exLazY3HWP78xdxymMNc/QBCTcEb21z/1J0XyesLYP0RGLbJ7ldk/6si0noJv2j9kVvaTy1DbP8whLWyUOdw/ET2wEB0q3T87o36LpyLePw3MYBl4I98/oWFSnmoW4D8q9Dzog5/gP6LTeI4tLeE/JlTVdY6/4T+7EZbOzlbiP1Saex8Y8+I/2h8qUZWU4z9ZU/G5cjvkP2+l+Cne5+Q/kUPT9waa5T8gRn8NHlLmP9ig0/VVEOc/iYVg6uLU5z9MCMbh+p/oPxv1hJ7Vcek/CehNvqxK6j8s3NLJuyrrP/6IH0VAEuw/Cwt9wHkB7T/0euXpqfjtP4I9DJ8U+O4/AAAAAAAA8D8AAAAAAADwP3Fd9Z7sAPA/VBKWS9kB8D/P6OIFxgLwPxWr3M2yA/A/ZiOEo58E8D8KHNqGjAXwP1hf33d5BvA/sbeUdmYH8D+D7/qCUwjwP0bREp1ACfA/fyfdxC0K8D+/vFr6GgvwP6BbjD0IDPA/zM5yjvUM8D/14A7t4g3wP9pcYVnQDvA/Rw1r070P8D8RvSxbqxDwPxw3p/CYEfA/VUbbk4YS8D+1tclEdBPwP0JQcwNiFPA/DuHYz08V8D81M/upPRbwP+AR25ErF/A/REh5hxkY8D+fodaKBxnwPz/p85v1GfA/eurRuuMa8D+0cHHn0RvwP11H0yHAHPA/7jn4aa4d8D/vE+G/nB7wP/KgjiOLH/A/lKwBlXkg8D+BAjsUaCHwP21uO6FWIvA/GrwDPEUj8D9Vt5TkMyTwP/cr75oiJfA/5OUTXxEm8D8OsQMxACfwP3BZvxDvJ/A/E6tH/t0o8D8Kcp35zCnwP3V6wQK8KvA/gJC0Gasr8D9hgHc+mizwP1wWC3GJLfA/vx5wsXgu8D/mZaf/Zy/wPza4sVtXMPA/IuKPxUYx8D8nsEI9NjLwP9HuysIlM/A/tGopVhU08D9x8F73BDXwP7dMbKb0NfA/P0xSY+Q28D/MuxEu1DfwPzFoqwbEOPA/SR4g7bM58D/+qnDhozrwP0PbneOTO/A/GHyo84M88D+KWpERdD3wP7FDWT1kPvA/sAQBd1Q/8D+2aom+REDwPwBD8xM1QfA/1Fo/dyVC8D+Ff27oFUPwP3J+gWcGRPA/ByV59PZE8D+5QFaP50XwPwyfGTjYRvA/jQ3E7shH8D/YWVazuUjwP5JR0YWqSfA/bcI1ZptK8D8oeoRUjEvwP4xGvlB9TPA/bvXjWm5N8D+xVPZyX07wP0Iy9phQT/A/GlzkzEFQ8D8/oMEOM1HwP8LMjl4kUvA/wK9MvBVT8D9iF/wnB1TwP9zRnaH4VPA/cK0yKepV8D9reLu+21bwPyUBOWLNV/A/AhasE79Y8D90hRXTsFnwP/cddqCiWvA/Eq7Oe5Rb8D9bBCBlhlzwP3Hvalx4XfA/AT6wYWpe8D/CvvB0XF/wP3pALZZOYPA/95FmxUBh8D8Wgp0CM2LwP7/f0k0lY/A/5XkHpxdk8D+JHzwOCmXwP7WfcYP8ZfA/gsmoBu9m8D8UbOKX4WfwP5pWHzfUaPA/T1hg5MZp8D98QKafuWrwP3Pe8Wisa/A/lQFEQJ9s8D9NeZ0lkm3wPxIV/xiFbvA/aKRpGnhv8D/e9t0pa3DwPxDcXEdecfA/pSPnclFy8D9RnX2sRHPwP9MYIfQ3dPA/9mXSSSt18D+TVJKtHnbwP4y0YR8Sd/A/0VVBnwV48D9dCDIt+XjwPzmcNMnsefA/duFJc+B68D82qHIr1HvwP6PAr/HHfPA/9voBxrt98D9xJ2qor37wP2UW6Zijf/A/LJh/l5eA8D8wfS6ki4HwP+KV9r5/gvA/xbLY53OD8D9ipNUeaITwP1I77mNchfA/Okgjt1CG8D/Im3UYRYfwP7kG5oc5iPA/1ll1BS6J8D/yZSSRIorwP+378yoXi/A/tOzk0guM8D8/CfiIAI3wP5MiLk31jfA/wAmIH+qO8D/ijwYA34/wPyOGqu7TkPA/uL1068iR8D/gB2b2vZLwP+k1fw+zk/A/LBnBNqiU8D8NgyxsnZXwPwBFwq+SlvA/fzCDAYiX8D8WF3BhfZjwP1nKic9ymfA/6hvRS2ia8D933UbWXZvwP7ng625TnPA/d/fAFUmd8D+D88bKPp7wP7um/o00n/A/CeNoXyqg8D9jegY/IKHwP80+2CwWovA/VQLfKAyj8D8VlxszAqTwPzXPjkv4pPA/6Xw5cu6l8D9uchyn5KbwPxGCOOrap/A/KH6OO9Go8D8ZOR+bx6nwP1OF6wi+qvA/UTX0hLSr8D+cGzoPq6zwP8gKvqehrfA/dtWATpiu8D9SToMDj6/wPxZIxsaFsPA/hpVKmHyx8D90CRF4c7LwP7x2GmZqs/A/SbBnYmG08D8PiflsWLXwPxLU0IVPtvA/X2TurEa38D8RDVPiPbjwP06h/yU1ufA/SPT0dyy68D8/2TPYI7vwP30jvUYbvPA/W6aRwxK98D87NbJOCr7wP46jH+gBv/A/zsTaj/m/8D+FbORF8cDwP0duPQrpwfA/tJ3m3ODC8D96zuC92MPwP1DULK3QxPA//YLLqsjF8D9Trr22wMbwPy4qBNG4x/A/ecqf+bDI8D8qY5EwqcnwP0PI2XWhyvA/1M15yZnL8D/3R3IrkszwP9QKxJuKzfA/nupvGoPO8D+Uu3ane8/wPwNS2UJ00PA/RIKY7GzR8D+6ILWkZdLwP9YBMGte0/A/FvoJQFfU8D8C3kMjUNXwPzKC3hRJ1vA/RbvaFELX8D/sXTkjO9jwP98++z802fA/5jIhay3a8D/VDqykJtvwP4mnnOwf3PA/8NHzQhnd8D8AY7KnEt7wP78v2RoM3/A/PQ1pnAXg8D+W0GIs/+DwP/VOx8r44fA/jV2Xd/Li8D+i0dMy7OPwP4GAffzl5PA/hT+V1N/l8D8V5Bu72ebwP6NDErDT5/A/sDN5s83o8D/GiVHFx+nwP38bnOXB6vA/fr5ZFLzr8D90SItRtuzwPx+PMZ2w7fA/SGhN96ru8D/Fqd9fpe/wP3cp6daf8PA/T71qXJrx8D9FO2XwlPLwPwAAAAAAAPA/Y3nZko/z8D/A1sfDmvXxPxW3MQr+BvM/i3KN+aIo9D9e7PAIgVv1P807f2aeoPY/sM9o1xD59z88bj2l/mX5P63TWpmf6Po/KcFOBz6C/D9DExDnNzT+PwAAAAAAAABAY3nZko/zAEDA1sfDmvUBQBW3MQr+BgNAi3KN+aIoBEBe7PAIgVsFQM07f2aeoAZAsM9o1xD5B0A9bj2l/mUJQK3TWpmf6ApAKcFOBz6CDEBEExDnNzQOQAAAAAAAABBAY3nZko/zEEC/1sfDmvURQBW3MQr+BhNAi3KN+aIoFEBd7PAIgVsVQM07f2aeoBZAsc9o1xD5F0A8bj2l/mUZQK3TWpmf6BpAKsFOBz6CHEBDExDnNzQeQAAAAAAAACBAY3nZko/zIEC/1sfDmvUhQBW3MQr+BiNAi3KN+aIoJEBd7PAIgVslQM07f2aeoCZAsc9o1xD5J0A8bj2l/mUpQK3TWpmf6CpAKsFOBz6CLEBDExDnNzQuQAAAAAAAADBAYnnZko/zMEDB1sfDmvUxQBW3MQr+BjNAinKN+aIoNEBf7PAIgVs1QM07f2aeoDZAr89o1xD5N0A+bj2l/mU5QK3TWpmf6DpAKMFOBz6CPEBFExDnNzQ+QAAAAAAAAEBAYnnZko/zQEDB1sfDmvVBQBW3MQr+BkNAinKN+aIoREBf7PAIgVtFQM07f2aeoEZAr89o1xD5R0A+bj2l/mVJQK3TWpmf6EpAKMFOBz6CTEBFExDnNzROQAAAAAAAAFBAYnnZko/zUEDB1sfDmvVRQBW3MQr+BlNAinKN+aIoVEBf7PAIgVtVQM07f2aeoFZAr89o1xD5V0A+bj2l/mVZQK3TWpmf6FpAKMFOBz6CXEBFExDnNzReQAAAAAAAAGBAYnnZko/zYEDB1sfDmvVhQBW3MQr+BmNAinKN+aIoZEBf7PAIgVtlQM07f2aeoGZAr89o1xD5Z0A+bj2l/mVpQK3TWpmf6GpAKMFOBz6CbEBFExDnNzRuQAAAAAAAAHBAZXnZko/zcEC+1sfDmvVxQBW3MQr+BnNAjXKN+aIodEBc7PAIgVt1QM07f2aeoHZAs89o1xD5d0A6bj2l/mV5QK3TWpmf6HpALcFOBz6CfEBAExDnNzR+QAAAAAAAAIBAZXnZko/zgEC+1sfDmvWBQBW3MQr+BoNAjXKN+aIohEBc7PAIgVuFQM07f2aeoIZAs89o1xD5h0A6bj2l/mWJQK3TWpmf6IpALcFOBz6CjEBAExDnNzSOQAAAAAAAAJBAZXnZko/zkEC+1sfDmvWRQBW3MQr+BpNAjXKN+aIolEBc7PAIgVuVQM07f2aeoJZAs89o1xD5l0ADAAAABAAAAAQAAAAGAAAAg/miAERObgD8KRUA0VcnAN009QBi28AAPJmVAEGQQwBjUf4Au96rALdhxQA6biQA0k1CAEkG4AAJ6i4AHJLRAOsd/gApsRwA6D6nAPU1ggBEuy4AnOmEALQmcABBfl8A1pE5AFODOQCc9DkAi1+EACj5vQD4HzsA3v+XAA+YBQARL+8AClqLAG0fbQDPfjYACcsnAEZPtwCeZj8ALepfALondQDl68cAPXvxAPc5BwCSUooA+2vqAB+xXwAIXY0AMANWAHv8RgDwq2sAILzPADb0mgDjqR0AXmGRAAgb5gCFmWUAoBRfAI1AaACA2P8AJ3NNAAYGMQDKVhUAyahzAHviYABrjMAAGcRHAM1nwwAJ6NwAWYMqAIt2xACmHJYARK/dABlX0QClPgUABQf/ADN+PwDCMugAmE/eALt9MgAmPcMAHmvvAJ/4XgA1HzoAf/LKAPGHHQB8kCEAaiR8ANVu+gAwLXcAFTtDALUUxgDDGZ0ArcTCACxNQQAMAF0Ahn1GAONxLQCbxpoAM2IAALTSfAC0p5cAN1XVANc+9gCjEBgATXb8AGSdKgBw16sAY3z4AHqwVwAXFecAwElWADvW2QCnhDgAJCPLANaKdwBaVCMAAB+5APEKGwAZzt8AnzH/AGYeagCZV2EArPtHAH5/2AAiZbcAMuiJAOa/YADvxM0AbDYJAF0/1AAW3tcAWDveAN6bkgDSIigAKIboAOJYTQDGyjIACOMWAOB9ywAXwFAA8x2nABjgWwAuEzQAgxJiAINIAQD1jlsArbB/AB7p8gBISkMAEGfTAKrd2ACuX0IAamHOAAoopADTmbQABqbyAFx3fwCjwoMAYTyIAIpzeACvjFoAb9e9AC2mYwD0v8sAjYHvACbBZwBVykUAytk2ACio0gDCYY0AEsl3AAQmFAASRpsAxFnEAMjFRABNspEAABfzANRDrQApSeUA/dUQAAC+/AAelMwAcM7uABM+9QDs8YAAs+fDAMf4KACTBZQAwXE+AC4JswALRfMAiBKcAKsgewAutZ8AR5LCAHsyLwAMVW0AcqeQAGvnHwAxy5YAeRZKAEF54gD034kA6JSXAOLmhACZMZcAiO1rAF9fNgC7/Q4ASJq0AGekbABxckIAjV0yAJ8VuAC85QkAjTElAPd0OQAwBRwADQwBAEsIaAAs7lgAR6qQAHTnAgC91iQA932mAG5IcgCfFu8AjpSmALSR9gDRU1EAzwryACCYMwD1S34AsmNoAN0+XwBAXQMAhYl/AFVSKQA3ZMAAbdgQADJIMgBbTHUATnHUAEVUbgALCcEAKvVpABRm1QAnB50AXQRQALQ72wDqdsUAh/kXAElrfQAdJ7oAlmkpAMbMrACtFFQAkOJqAIjZiQAsclAABKS+AHcHlADzMHAAAPwnAOpxqABmwkkAZOA9AJfdgwCjP5cAQ5T9AA2GjAAxQd4AkjmdAN1wjAAXt+cACN87ABU3KwBcgKAAWoCTABARkgAP6NgAbICvANv/SwA4kA8AWRh2AGKlFQBhy7sAx4m5ABBAvQDS8gQASXUnAOu29gDbIrsAChSqAIkmLwBkg3YACTszAA6UGgBROqoAHaPCAK/trgBcJhIAbcJNAC16nADAVpcAAz+DAAnw9gArQIwAbTGZADm0BwAMIBUA2MNbAPWSxADGrUsATsqlAKc3zQDmqTYAq5KUAN1CaAAZY94AdozvAGiLUgD82zcArqGrAN8VMQAArqEADPvaAGRNZgDtBbcAKWUwAFdWvwBH/zoAavm5AHW+8wAok98Aq4AwAGaM9gAEyxUA+iIGANnkHQA9s6QAVxuPADbNCQBOQukAE76kADMjtQDwqhoAT2WoANLBpQALPw8AW3jNACP5dgB7iwQAiRdyAMamUwBvbuIA7+sAAJtKWADE2rcAqma6AHbPzwDRAh0AsfEtAIyZwQDDrXcAhkjaAPddoADGgPQArPAvAN3smgA/XLwA0N5tAJDHHwAq27YAoyU6AACvmgCtU5MAtlcEACkttABLgH4A2genAHaqDgB7WaEAFhIqANy3LQD65f0Aidv+AIm+/QDkdmwABqn8AD6AcACFbhUA/Yf/ACg+BwBhZzMAKhiGAE296gCz568Aj21uAJVnOQAxv1sAhNdIADDfFgDHLUMAJWE1AMlwzgAwy7gAv2z9AKQAogAFbOQAWt2gACFvRwBiEtIAuVyEAHBhSQBrVuAAmVIBAFBVNwAe1bcAM/HEABNuXwBdMOQAhS6pAB2ywwChMjYACLekAOqx1AAW9yEAj2nkACf/dwAMA4AAjUAtAE/NoAAgpZkAs6LTAC9dCgC0+UIAEdrLAH2+0ACb28EAqxe9AMqigQAIalwALlUXACcAVQB/FPAA4QeGABQLZACWQY0Ah77eANr9KgBrJbYAe4k0AAXz/gC5v54AaGpPAEoqqABPxFoALfi8ANdamAD0x5UADU2NACA6pgCkV18AFD+xAIA4lQDMIAEAcd2GAMnetgC/YPUATWURAAEHawCMsKwAssDQAFFVSAAe+w4AlXLDAKMGOwDAQDUABtx7AOBFzABOKfoA1srIAOjzQQB8ZN4Am2TYANm+MQCkl8MAd1jUAGnjxQDw2hMAujo8AEYYRgBVdV8A0r31AG6SxgCsLl0ADkTtABw+QgBhxIcAKf3pAOfW8wAifMoAb5E1AAjgxQD/140AbmriALD9xgCTCMEAfF10AGutsgDNbp0APnJ7AMYRagD3z6kAKXPfALXJugC3AFEA4rINAHS6JADlfWAAdNiKAA0VLACBGAwAfmaUAAEpFgCfenYA/f2+AFZF7wDZfjYA7NkTAIu6uQDEl/wAMagnAPFuwwCUxTYA2KhWALSotQDPzA4AEoktAG9XNAAsVokAmc7jANYguQBrXqoAPiqcABFfzAD9C0oA4fT7AI47bQDihiwA6dSEAPy0qQDv7tEALjXJAC85YQA4IUQAG9nIAIH8CgD7SmoALxzYAFO0hABOmYwAVCLMACpV3ADAxtYACxmWABpwuABplWQAJlpgAD9S7gB/EQ8A9LURAPzL9QA0vC0ANLzuAOhdzADdXmAAZ46bAJIz7wDJF7gAYVibAOFXvABRg8YA2D4QAN1xSAAtHN0ArxihACEsRgBZ89cA2XqYAJ5UwABPhvoAVgb8AOV5rgCJIjYAOK0iAGeT3ABV6KoAgiY4AMrnmwBRDaQAmTOxAKnXDgBpBUgAZbLwAH+IpwCITJcA+dE2ACGSswB7gkoAmM8hAECf3ADcR1UA4XQ6AGfrQgD+nd8AXtRfAHtnpAC6rHoAVfaiACuIIwBBulUAWW4IACEqhgA5R4MAiePmAOWe1ABJ+0AA/1bpABwPygDFWYoAlPorANPBxQAPxc8A21quAEfFhgCFQ2IAIYY7ACx5lAAQYYcAKkx7AIAsGgBDvxIAiCaQAHg8iQCoxOQA5dt7AMQ6wgAm9OoA92eKAA2SvwBloysAPZOxAL18CwCkUdwAJ91jAGnh3QCalBkAqCmVAGjOKAAJ7bQARJ8gAE6YygBwgmMAfnwjAA+5MgCn9Y4AFFbnACHxCAC1nSoAb35NAKUZUQC1+asAgt/WAJbdYQAWNgIAxDqfAIOioQBy7W0AOY16AIK4qQBrMlwARidbAAA07QDSAHcA/PRVAAFZTQDgcYAAQfPDAAs9QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNQBBsMQACwPAKVA=";
    if (!isDataURI(wasmBinaryFile)) {
      wasmBinaryFile = locateFile(wasmBinaryFile);
    }
    function getBinary(file) {
      try {
        if (file == wasmBinaryFile && wasmBinary) {
          return new Uint8Array(wasmBinary);
        }
        var binary = tryParseAsDataURI(file);
        if (binary) {
          return binary;
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw "both async and sync fetching of the wasm failed";
      } catch (err) {
        abort(err);
      }
    }
    function getBinaryPromise() {
      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
        if (typeof fetch == "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" })
            .then(function (response) {
              if (!response["ok"]) {
                throw (
                  "failed to load wasm binary file at '" + wasmBinaryFile + "'"
                );
              }
              return response["arrayBuffer"]();
            })
            .catch(function () {
              return getBinary(wasmBinaryFile);
            });
        }
      }
      return Promise.resolve().then(function () {
        return getBinary(wasmBinaryFile);
      });
    }
    function createWasm() {
      var info = { a: asmLibraryArg };
      function receiveInstance(instance, module) {
        var exports = instance.exports;
        Module["asm"] = exports;
        wasmMemory = Module["asm"]["j"];
        updateGlobalBufferAndViews(wasmMemory.buffer);
        wasmTable = Module["asm"]["t"];
        addOnInit(Module["asm"]["k"]);
        removeRunDependency("wasm-instantiate");
      }
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result) {
        receiveInstance(result["instance"]);
      }
      function instantiateArrayBuffer(receiver) {
        return getBinaryPromise()
          .then(function (binary) {
            return WebAssembly.instantiate(binary, info);
          })
          .then(function (instance) {
            return instance;
          })
          .then(receiver, function (reason) {
            err("failed to asynchronously prepare wasm: " + reason);
            abort(reason);
          });
      }
      function instantiateAsync() {
        if (
          !wasmBinary &&
          typeof WebAssembly.instantiateStreaming == "function" &&
          !isDataURI(wasmBinaryFile) &&
          typeof fetch == "function"
        ) {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(
            function (response) {
              var result = WebAssembly.instantiateStreaming(response, info);
              return result.then(receiveInstantiationResult, function (reason) {
                err("wasm streaming compile failed: " + reason);
                err("falling back to ArrayBuffer instantiation");
                return instantiateArrayBuffer(receiveInstantiationResult);
              });
            }
          );
        } else {
          return instantiateArrayBuffer(receiveInstantiationResult);
        }
      }
      if (Module["instantiateWasm"]) {
        try {
          var exports = Module["instantiateWasm"](info, receiveInstance);
          return exports;
        } catch (e) {
          err("Module.instantiateWasm callback failed with error: " + e);
          return false;
        }
      }
      instantiateAsync().catch(readyPromiseReject);
      return {};
    }
    var tempDouble;
    var tempI64;
    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    }
    function intArrayToString(array) {
      var ret = [];
      for (var i = 0; i < array.length; i++) {
        var chr = array[i];
        if (chr > 255) {
          if (ASSERTIONS) {
            assert(
              false,
              "Character code " +
                chr +
                " (" +
                String.fromCharCode(chr) +
                ")  at offset " +
                i +
                " not in 0x00-0xFF."
            );
          }
          chr &= 255;
        }
        ret.push(String.fromCharCode(chr));
      }
      return ret.join("");
    }
    function writeArrayToMemory(array, buffer) {
      HEAP8.set(array, buffer);
    }
    function setErrNo(value) {
      HEAP32[___errno_location() >> 2] = value;
      return value;
    }
    var PATH = {
      isAbs: (path) => path.charAt(0) === "/",
      splitPath: (filename) => {
        var splitPathRe =
          /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: (parts, allowAboveRoot) => {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === ".") {
            parts.splice(i, 1);
          } else if (last === "..") {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }
        return parts;
      },
      normalize: (path) => {
        var isAbsolute = PATH.isAbs(path),
          trailingSlash = path.substr(-1) === "/";
        path = PATH.normalizeArray(
          path.split("/").filter((p) => !!p),
          !isAbsolute
        ).join("/");
        if (!path && !isAbsolute) {
          path = ".";
        }
        if (path && trailingSlash) {
          path += "/";
        }
        return (isAbsolute ? "/" : "") + path;
      },
      dirname: (path) => {
        var result = PATH.splitPath(path),
          root = result[0],
          dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
      basename: (path) => {
        if (path === "/") return "/";
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf("/");
        if (lastSlash === -1) return path;
        return path.substr(lastSlash + 1);
      },
      join: function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join("/"));
      },
      join2: (l, r) => {
        return PATH.normalize(l + "/" + r);
      },
    };
    function getRandomDevice() {
      if (
        typeof crypto == "object" &&
        typeof crypto["getRandomValues"] == "function"
      ) {
        var randomBuffer = new Uint8Array(1);
        return () => {
          crypto.getRandomValues(randomBuffer);
          return randomBuffer[0];
        };
      } else return () => abort("randomDevice");
    }
    var PATH_FS = {
      resolve: function () {
        var resolvedPath = "",
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : FS.cwd();
          if (typeof path != "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path) {
            return "";
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        resolvedPath = PATH.normalizeArray(
          resolvedPath.split("/").filter((p) => !!p),
          !resolvedAbsolute
        ).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      },
      relative: (from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== "") break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== "") break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split("/"));
        var toParts = trim(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      },
    };
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(
        stringy,
        u8array,
        0,
        u8array.length
      );
      if (dontAddNull) u8array.length = numBytesWritten;
      return u8array;
    }
    var TTY = {
      ttys: [],
      init: function () {},
      shutdown: function () {},
      register: function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open: function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
        close: function (stream) {
          stream.tty.ops.flush(stream.tty);
        },
        flush: function (stream) {
          stream.tty.ops.flush(stream.tty);
        },
        read: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        },
      },
      default_tty_ops: {
        get_char: function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (
              typeof window != "undefined" &&
              typeof window.prompt == "function"
            ) {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        flush: function (tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
      },
      default_tty1_ops: {
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        flush: function (tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
      },
    };
    function mmapAlloc(size) {
      abort();
    }
    var MEMFS = {
      ops_table: null,
      mount: function (mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0);
      },
      createNode: function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink,
              },
              stream: { llseek: MEMFS.stream_ops.llseek },
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync,
              },
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink,
              },
              stream: {},
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
              },
              stream: FS.chrdev_stream_ops,
            },
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
      getFileDataAsTypedArray: function (node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage: function (node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(
          newCapacity,
          (prevCapacity *
            (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>>
            0
        );
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
      },
      resizeFileStorage: function (node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(
              oldContents.subarray(0, Math.min(newSize, node.usedBytes))
            );
          }
          node.usedBytes = newSize;
        }
      },
      node_ops: {
        getattr: function (node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr: function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup: function (parent, name) {
          throw FS.genericErrors[44];
        },
        mknod: function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
        rename: function (old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {}
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },
        unlink: function (parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        rmdir: function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        readdir: function (node) {
          var entries = [".", ".."];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },
        symlink: function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink: function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        },
      },
      stream_ops: {
        read: function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer[offset + i] = contents[position + i];
          }
          return size;
        },
        write: function (stream, buffer, offset, length, position, canOwn) {
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(
                buffer.subarray(offset, offset + length),
                position
              );
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer.subarray) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek: function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        allocate: function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(
            stream.node.usedBytes,
            offset + length
          );
        },
        mmap: function (stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },
        msync: function (stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            return 0;
          }
          var bytesWritten = MEMFS.stream_ops.write(
            stream,
            buffer,
            0,
            length,
            offset,
            false
          );
          return 0;
        },
      },
    };
    function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
      readAsync(
        url,
        (arrayBuffer) => {
          assert(
            arrayBuffer,
            'Loading data file "' + url + '" failed (no arrayBuffer).'
          );
          onload(new Uint8Array(arrayBuffer));
          if (dep) removeRunDependency(dep);
        },
        (event) => {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        }
      );
      if (dep) addRunDependency(dep);
    }
    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: "/",
      initialized: false,
      ignorePermissions: true,
      ErrnoError: null,
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      lookupPath: (path, opts = {}) => {
        path = PATH_FS.resolve(FS.cwd(), path);
        if (!path) return { path: "", node: null };
        var defaults = { follow_mount: true, recurse_count: 0 };
        opts = Object.assign(defaults, opts);
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }
        var parts = PATH.normalizeArray(
          path.split("/").filter((p) => !!p),
          false
        );
        var current = FS.root;
        var current_path = "/";
        for (var i = 0; i < parts.length; i++) {
          var islast = i === parts.length - 1;
          if (islast && opts.parent) {
            break;
          }
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, {
                recurse_count: opts.recurse_count + 1,
              });
              current = lookup.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
        return { path: current_path, node: current };
      },
      getPath: (node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length - 1] !== "/"
              ? mount + "/" + path
              : mount + path;
          }
          path = path ? node.name + "/" + path : node.name;
          node = node.parent;
        }
      },
      hashName: (parentid, name) => {
        var hash = 0;
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },
      hashAddNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
      lookupNode: (parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        return FS.lookup(parent, name);
      },
      createNode: (parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node;
      },
      destroyNode: (node) => {
        FS.hashRemoveNode(node);
      },
      isRoot: (node) => {
        return node === node.parent;
      },
      isMountpoint: (node) => {
        return !!node.mounted;
      },
      isFile: (mode) => {
        return (mode & 61440) === 32768;
      },
      isDir: (mode) => {
        return (mode & 61440) === 16384;
      },
      isLink: (mode) => {
        return (mode & 61440) === 40960;
      },
      isChrdev: (mode) => {
        return (mode & 61440) === 8192;
      },
      isBlkdev: (mode) => {
        return (mode & 61440) === 24576;
      },
      isFIFO: (mode) => {
        return (mode & 61440) === 4096;
      },
      isSocket: (mode) => {
        return (mode & 49152) === 49152;
      },
      flagModes: { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 },
      modeStringToFlags: (str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == "undefined") {
          throw new Error("Unknown file open mode: " + str);
        }
        return flags;
      },
      flagsToPermissionString: (flag) => {
        var perms = ["r", "w", "rw"][flag & 3];
        if (flag & 512) {
          perms += "w";
        }
        return perms;
      },
      nodePermissions: (node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        if (perms.includes("r") && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes("w") && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes("x") && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
      mayLookup: (dir) => {
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },
      mayCreate: (dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {}
        return FS.nodePermissions(dir, "wx");
      },
      mayDelete: (dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, "wx");
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
      mayOpen: (node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
      MAX_OPEN_FDS: 4096,
      nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
      getStream: (fd) => FS.streams[fd],
      createStream: (stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = function () {
            this.shared = {};
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function () {
                return this.node;
              },
              set: function (val) {
                this.node = val;
              },
            },
            isRead: {
              get: function () {
                return (this.flags & 2097155) !== 1;
              },
            },
            isWrite: {
              get: function () {
                return (this.flags & 2097155) !== 0;
              },
            },
            isAppend: {
              get: function () {
                return this.flags & 1024;
              },
            },
            flags: {
              get: function () {
                return this.shared.flags;
              },
              set: function (val) {
                this.shared.flags = val;
              },
            },
            position: {
              get: function () {
                return this.shared.position;
              },
              set: function (val) {
                this.shared.position = val;
              },
            },
          });
        }
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
      closeStream: (fd) => {
        FS.streams[fd] = null;
      },
      chrdev_stream_ops: {
        open: (stream) => {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },
        llseek: () => {
          throw new FS.ErrnoError(70);
        },
      },
      major: (dev) => dev >> 8,
      minor: (dev) => dev & 255,
      makedev: (ma, mi) => (ma << 8) | mi,
      registerDevice: (dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },
      getDevice: (dev) => FS.devices[dev],
      getMounts: (mount) => {
        var mounts = [];
        var check = [mount];
        while (check.length) {
          var m = check.pop();
          mounts.push(m);
          check.push.apply(check, m.mounts);
        }
        return mounts;
      },
      syncfs: (populate, callback) => {
        if (typeof populate == "function") {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          err(
            "warning: " +
              FS.syncFSRequests +
              " FS.syncfs operations in flight at once, probably just doing extra work"
          );
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount: (type, opts, mountpoint) => {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          mountpoint = lookup.path;
          node = lookup.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: [],
        };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot;
      },
      unmount: (mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
          while (current) {
            var next = current.name_next;
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup: (parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },
      mknod: (path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === "." || name === "..") {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
      create: (path, mode) => {
        mode = mode !== undefined ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },
      mkdir: (path, mode) => {
        mode = mode !== undefined ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },
      mkdirTree: (path, mode) => {
        var dirs = path.split("/");
        var d = "";
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += "/" + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch (e) {
            if (e.errno != 20) throw e;
          }
        }
      },
      mkdev: (path, mode, dev) => {
        if (typeof dev == "undefined") {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },
      symlink: (oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename: (old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {}
        if (old_node === new_node) {
          return;
        }
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        errCode = new_node
          ? FS.mayDelete(new_dir, new_name, isdir)
          : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (
          FS.isMountpoint(old_node) ||
          (new_node && FS.isMountpoint(new_node))
        ) {
          throw new FS.ErrnoError(10);
        }
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          FS.hashAddNode(old_node);
        }
      },
      rmdir: (path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
      readdir: (path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
      unlink: (path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
      readlink: (path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(
          FS.getPath(link.parent),
          link.node_ops.readlink(link)
        );
      },
      stat: (path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
      lstat: (path) => {
        return FS.stat(path, true);
      },
      chmod: (path, mode, dontFollow) => {
        var node;
        if (typeof path == "string") {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now(),
        });
      },
      lchmod: (path, mode) => {
        FS.chmod(path, mode, true);
      },
      fchmod: (fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },
      chown: (path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == "string") {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, { timestamp: Date.now() });
      },
      lchown: (path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },
      fchown: (fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },
      truncate: (path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == "string") {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
      },
      ftruncate: (fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
      utime: (path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
      },
      open: (path, flags, mode) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == "string" ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == "undefined" ? 438 : mode;
        if (flags & 64) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == "object") {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
            node = lookup.node;
          } catch (e) {}
        }
        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        if (flags & 512 && !created) {
          FS.truncate(node, 0);
        }
        flags &= ~(128 | 512 | 131072);
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          ungotten: [],
          error: false,
        });
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module["logReadFiles"] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },
      close: (stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
      isClosed: (stream) => {
        return stream.fd === null;
      },
      llseek: (stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
      read: (stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(
          stream,
          buffer,
          offset,
          length,
          position
        );
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
      write: (stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(
          stream,
          buffer,
          offset,
          length,
          position,
          canOwn
        );
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },
      allocate: (stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
      mmap: (stream, length, position, prot, flags) => {
        if (
          (prot & 2) !== 0 &&
          (flags & 2) === 0 &&
          (stream.flags & 2097155) !== 2
        ) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(
          stream,
          buffer,
          offset,
          length,
          mmapFlags
        );
      },
      munmap: (stream) => 0,
      ioctl: (stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
      readFile: (path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
      writeFile: (path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }
        FS.close(stream);
      },
      cwd: () => FS.currentPath,
      chdir: (path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, "x");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
      createDefaultDirectories: () => {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      },
      createDefaultDevices: () => {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var random_device = getRandomDevice();
        FS.createDevice("/dev", "random", random_device);
        FS.createDevice("/dev", "urandom", random_device);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      },
      createSpecialDirectories: () => {
        FS.mkdir("/proc");
        var proc_self = FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount(
          {
            mount: () => {
              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
              node.node_ops = {
                lookup: (parent, name) => {
                  var fd = +name;
                  var stream = FS.getStream(fd);
                  if (!stream) throw new FS.ErrnoError(8);
                  var ret = {
                    parent: null,
                    mount: { mountpoint: "fake" },
                    node_ops: { readlink: () => stream.path },
                  };
                  ret.parent = ret;
                  return ret;
                },
              };
              return node;
            },
          },
          {},
          "/proc/self/fd"
        );
      },
      createStandardStreams: () => {
        if (Module["stdin"]) {
          FS.createDevice("/dev", "stdin", Module["stdin"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }
        if (Module["stdout"]) {
          FS.createDevice("/dev", "stdout", null, Module["stdout"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }
        if (Module["stderr"]) {
          FS.createDevice("/dev", "stderr", null, Module["stderr"]);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }
        var stdin = FS.open("/dev/stdin", 0);
        var stdout = FS.open("/dev/stdout", 1);
        var stderr = FS.open("/dev/stderr", 1);
      },
      ensureErrnoError: () => {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function (errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = "FS error";
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = "<generic error, no stack>";
        });
      },
      staticInit: () => {
        FS.ensureErrnoError();
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = { MEMFS: MEMFS };
      },
      init: (input, output, error) => {
        FS.init.initialized = true;
        FS.ensureErrnoError();
        Module["stdin"] = input || Module["stdin"];
        Module["stdout"] = output || Module["stdout"];
        Module["stderr"] = error || Module["stderr"];
        FS.createStandardStreams();
      },
      quit: () => {
        FS.init.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
      getMode: (canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },
      findObject: (path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
      analyzePath: (path, dontResolveLastLink) => {
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {}
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null,
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === "/";
        } catch (e) {
          ret.error = e.errno;
        }
        return ret;
      },
      createPath: (parent, path, canRead, canWrite) => {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        var parts = path.split("/").reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {}
          parent = current;
        }
        return current;
      },
      createFile: (parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },
      createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == "string" ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == "string") {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i)
              arr[i] = data.charCodeAt(i);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },
      createDevice: (parent, name, input, output) => {
        var path = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          },
        });
        return FS.mkdev(path, mode, dev);
      },
      forceLoadFile: (obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        if (typeof XMLHttpRequest != "undefined") {
          throw new Error(
            "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
          );
        } else if (read_) {
          try {
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error("Cannot load without read() or XMLHttpRequest.");
        }
      },
      createLazyFile: (parent, name, url, canRead, canWrite) => {
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize) | 0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter =
          function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          };
        LazyUint8Array.prototype.cacheLength =
          function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (
              !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)
            )
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr.status
              );
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing =
              (header = xhr.getResponseHeader("Accept-Ranges")) &&
              header === "bytes";
            var usesGzip =
              (header = xhr.getResponseHeader("Content-Encoding")) &&
              header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing) chunkSize = datalength;
            var doXHR = (from, to) => {
              if (from > to)
                throw new Error(
                  "invalid range (" +
                    from +
                    ", " +
                    to +
                    ") or no bytes requested!"
                );
              if (to > datalength - 1)
                throw new Error(
                  "only " + datalength + " bytes available! programmer error!"
                );
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
              xhr.responseType = "arraybuffer";
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr.send(null);
              if (
                !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)
              )
                throw new Error(
                  "Couldn't load " + url + ". Status: " + xhr.status
                );
              if (xhr.response !== undefined) {
                return new Uint8Array(xhr.response || []);
              }
              return intArrayFromString(xhr.responseText || "", true);
            };
            var lazyArray = this;
            lazyArray.setDataGetter((chunkNum) => {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray.chunks[chunkNum] == "undefined") {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray.chunks[chunkNum] == "undefined")
                throw new Error("doXHR failed!");
              return lazyArray.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out(
                "LazyFiles on gzip forces download of the whole file when length is accessed"
              );
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          };
        if (typeof XMLHttpRequest != "undefined") {
          if (!ENVIRONMENT_IS_WORKER)
            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              },
            },
            chunkSize: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              },
            },
          });
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, {
          usedBytes: {
            get: function () {
              return this.contents.length;
            },
          },
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length) return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position);
        };
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr: ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },
      createPreloadedFile: (
        parent,
        name,
        url,
        canRead,
        canWrite,
        onload,
        onerror,
        dontCreateFile,
        canOwn,
        preFinish
      ) => {
        var fullname = name
          ? PATH_FS.resolve(PATH.join2(parent, name))
          : parent;
        var dep = getUniqueRunDependency("cp " + fullname);
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(
                parent,
                name,
                byteArray,
                canRead,
                canWrite,
                canOwn
              );
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (
            Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
              if (onerror) onerror();
              removeRunDependency(dep);
            })
          ) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == "string") {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },
      indexedDB: () => {
        return (
          window.indexedDB ||
          window.mozIndexedDB ||
          window.webkitIndexedDB ||
          window.msIndexedDB
        );
      },
      DB_NAME: () => {
        return "EM_FS_" + window.location.pathname;
      },
      DB_VERSION: 20,
      DB_STORE_NAME: "FILE_DATA",
      saveFilesToDB: (paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out("creating db");
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
            fail = 0,
            total = paths.length;
          function finish() {
            if (fail == 0) onload();
            else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(
              FS.analyzePath(path).object.contents,
              path
            );
            putRequest.onsuccess = () => {
              ok++;
              if (ok + fail == total) finish();
            };
            putRequest.onerror = () => {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
      loadFilesFromDB: (paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror;
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
          } catch (e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
            fail = 0,
            total = paths.length;
          function finish() {
            if (fail == 0) onload();
            else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(
                PATH.dirname(path),
                PATH.basename(path),
                getRequest.result,
                true,
                true,
                true
              );
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
    };
    var SYSCALLS = {
      DEFAULT_POLLMASK: 5,
      calculateAt: function (dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = FS.getStream(dirfd);
          if (!dirstream) throw new FS.ErrnoError(8);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },
      doStat: function (func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (
            e &&
            e.node &&
            PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))
          ) {
            return -54;
          }
          throw e;
        }
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[(buf + 8) >> 2] = stat.ino;
        HEAP32[(buf + 12) >> 2] = stat.mode;
        HEAP32[(buf + 16) >> 2] = stat.nlink;
        HEAP32[(buf + 20) >> 2] = stat.uid;
        HEAP32[(buf + 24) >> 2] = stat.gid;
        HEAP32[(buf + 28) >> 2] = stat.rdev;
        (tempI64 = [
          stat.size >>> 0,
          ((tempDouble = stat.size),
          +Math.abs(tempDouble) >= 1
            ? tempDouble > 0
              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 40) >> 2] = tempI64[0]),
          (HEAP32[(buf + 44) >> 2] = tempI64[1]);
        HEAP32[(buf + 48) >> 2] = 4096;
        HEAP32[(buf + 52) >> 2] = stat.blocks;
        (tempI64 = [
          Math.floor(stat.atime.getTime() / 1e3) >>> 0,
          ((tempDouble = Math.floor(stat.atime.getTime() / 1e3)),
          +Math.abs(tempDouble) >= 1
            ? tempDouble > 0
              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 56) >> 2] = tempI64[0]),
          (HEAP32[(buf + 60) >> 2] = tempI64[1]);
        HEAP32[(buf + 64) >> 2] = 0;
        (tempI64 = [
          Math.floor(stat.mtime.getTime() / 1e3) >>> 0,
          ((tempDouble = Math.floor(stat.mtime.getTime() / 1e3)),
          +Math.abs(tempDouble) >= 1
            ? tempDouble > 0
              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 72) >> 2] = tempI64[0]),
          (HEAP32[(buf + 76) >> 2] = tempI64[1]);
        HEAP32[(buf + 80) >> 2] = 0;
        (tempI64 = [
          Math.floor(stat.ctime.getTime() / 1e3) >>> 0,
          ((tempDouble = Math.floor(stat.ctime.getTime() / 1e3)),
          +Math.abs(tempDouble) >= 1
            ? tempDouble > 0
              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 88) >> 2] = tempI64[0]),
          (HEAP32[(buf + 92) >> 2] = tempI64[1]);
        HEAP32[(buf + 96) >> 2] = 0;
        (tempI64 = [
          stat.ino >>> 0,
          ((tempDouble = stat.ino),
          +Math.abs(tempDouble) >= 1
            ? tempDouble > 0
              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 104) >> 2] = tempI64[0]),
          (HEAP32[(buf + 108) >> 2] = tempI64[1]);
        return 0;
      },
      doMsync: function (addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
      varargs: undefined,
      get: function () {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];
        return ret;
      },
      getStr: function (ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
      getStreamFromFD: function (fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },
    };
    function ___syscall_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = SYSCALLS.get();
            if (arg < 0) {
              return -28;
            }
            var newStream;
            newStream = FS.createStream(stream, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream.flags;
          case 4: {
            var arg = SYSCALLS.get();
            stream.flags |= arg;
            return 0;
          }
          case 5: {
            var arg = SYSCALLS.get();
            var offset = 0;
            HEAP16[(arg + offset) >> 1] = 2;
            return 0;
          }
          case 6:
          case 7:
            return 0;
          case 16:
          case 8:
            return -28;
          case 9:
            setErrNo(28);
            return -1;
          default: {
            return -28;
          }
        }
      } catch (e) {
        if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }
    function ___syscall_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (op) {
          case 21509:
          case 21505: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21510:
          case 21511:
          case 21512:
          case 21506:
          case 21507:
          case 21508: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21519: {
            if (!stream.tty) return -59;
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = 0;
            return 0;
          }
          case 21520: {
            if (!stream.tty) return -59;
            return -28;
          }
          case 21531: {
            var argp = SYSCALLS.get();
            return FS.ioctl(stream, op, argp);
          }
          case 21523: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21524: {
            if (!stream.tty) return -59;
            return 0;
          }
          default:
            return -28;
        }
      } catch (e) {
        if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }
    function ___syscall_openat(dirfd, path, flags, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        var mode = varargs ? SYSCALLS.get() : 0;
        return FS.open(path, flags, mode).fd;
      } catch (e) {
        if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }
    function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }
    function abortOnCannotGrowMemory(requestedSize) {
      abort("OOM");
    }
    function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      abortOnCannotGrowMemory(requestedSize);
    }
    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }
    function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[(iov + 4) >> 2];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break;
      }
      return ret;
    }
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream, iov, iovcnt);
        HEAP32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }
    function convertI32PairToI53Checked(lo, hi) {
      return (hi + 2097152) >>> 0 < 4194305 - !!lo
        ? (lo >>> 0) + hi * 4294967296
        : NaN;
    }
    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      try {
        var offset = convertI32PairToI53Checked(offset_low, offset_high);
        if (isNaN(offset)) return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream, offset, whence);
        (tempI64 = [
          stream.position >>> 0,
          ((tempDouble = stream.position),
          +Math.abs(tempDouble) >= 1
            ? tempDouble > 0
              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
                ) >>> 0
            : 0),
        ]),
          (HEAP32[newOffset >> 2] = tempI64[0]),
          (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);
        if (stream.getdents && offset === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }
    function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[(iov + 4) >> 2];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
      }
      return ret;
    }
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }
    function getCFunc(ident) {
      var func = Module["_" + ident];
      return func;
    }
    function ccall(ident, returnType, argTypes, args, opts) {
      var toC = {
        string: (str) => {
          var ret = 0;
          if (str !== null && str !== undefined && str !== 0) {
            var len = (str.length << 2) + 1;
            ret = stackAlloc(len);
            stringToUTF8(str, ret, len);
          }
          return ret;
        },
        array: (arr) => {
          var ret = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        },
      };
      function convertReturnValue(ret) {
        if (returnType === "string") {
          return UTF8ToString(ret);
        }
        if (returnType === "boolean") return Boolean(ret);
        return ret;
      }
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func.apply(null, cArgs);
      function onDone(ret) {
        if (stack !== 0) stackRestore(stack);
        return convertReturnValue(ret);
      }
      ret = onDone(ret);
      return ret;
    }
    var FSNode = function (parent, name, mode, rdev) {
      if (!parent) {
        parent = this;
      }
      this.parent = parent;
      this.mount = parent.mount;
      this.mounted = null;
      this.id = FS.nextInode++;
      this.name = name;
      this.mode = mode;
      this.node_ops = {};
      this.stream_ops = {};
      this.rdev = rdev;
    };
    var readMode = 292 | 73;
    var writeMode = 146;
    Object.defineProperties(FSNode.prototype, {
      read: {
        get: function () {
          return (this.mode & readMode) === readMode;
        },
        set: function (val) {
          val ? (this.mode |= readMode) : (this.mode &= ~readMode);
        },
      },
      write: {
        get: function () {
          return (this.mode & writeMode) === writeMode;
        },
        set: function (val) {
          val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);
        },
      },
      isFolder: {
        get: function () {
          return FS.isDir(this.mode);
        },
      },
      isDevice: {
        get: function () {
          return FS.isChrdev(this.mode);
        },
      },
    });
    FS.FSNode = FSNode;
    FS.staticInit();
    var ASSERTIONS = false;
    var decodeBase64 =
      typeof atob == "function"
        ? atob
        : function (input) {
            var keyStr =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            do {
              enc1 = keyStr.indexOf(input.charAt(i++));
              enc2 = keyStr.indexOf(input.charAt(i++));
              enc3 = keyStr.indexOf(input.charAt(i++));
              enc4 = keyStr.indexOf(input.charAt(i++));
              chr1 = (enc1 << 2) | (enc2 >> 4);
              chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
              chr3 = ((enc3 & 3) << 6) | enc4;
              output = output + String.fromCharCode(chr1);
              if (enc3 !== 64) {
                output = output + String.fromCharCode(chr2);
              }
              if (enc4 !== 64) {
                output = output + String.fromCharCode(chr3);
              }
            } while (i < input.length);
            return output;
          };
    function intArrayFromBase64(s) {
      try {
        var decoded = decodeBase64(s);
        var bytes = new Uint8Array(decoded.length);
        for (var i = 0; i < decoded.length; ++i) {
          bytes[i] = decoded.charCodeAt(i);
        }
        return bytes;
      } catch (_) {
        throw new Error("Converting base64 string to bytes failed.");
      }
    }
    function tryParseAsDataURI(filename) {
      if (!isDataURI(filename)) {
        return;
      }
      return intArrayFromBase64(filename.slice(dataURIPrefix.length));
    }
    var asmLibraryArg = {
      c: ___syscall_fcntl64,
      g: ___syscall_ioctl,
      h: ___syscall_openat,
      i: _emscripten_memcpy_big,
      e: _emscripten_resize_heap,
      a: _fd_close,
      f: _fd_read,
      d: _fd_seek,
      b: _fd_write,
    };
    var asm = createWasm();
    var ___wasm_call_ctors = (Module["___wasm_call_ctors"] = function () {
      return (___wasm_call_ctors = Module["___wasm_call_ctors"] =
        Module["asm"]["k"]).apply(null, arguments);
    });
    var _malloc = (Module["_malloc"] = function () {
      return (_malloc = Module["_malloc"] = Module["asm"]["l"]).apply(
        null,
        arguments
      );
    });
    var _free = (Module["_free"] = function () {
      return (_free = Module["_free"] = Module["asm"]["m"]).apply(
        null,
        arguments
      );
    });
    var _mid_song_start = (Module["_mid_song_start"] = function () {
      return (_mid_song_start = Module["_mid_song_start"] =
        Module["asm"]["n"]).apply(null, arguments);
    });
    var _mid_song_seek = (Module["_mid_song_seek"] = function () {
      return (_mid_song_seek = Module["_mid_song_seek"] =
        Module["asm"]["o"]).apply(null, arguments);
    });
    var _mid_song_get_total_time = (Module["_mid_song_get_total_time"] =
      function () {
        return (_mid_song_get_total_time = Module["_mid_song_get_total_time"] =
          Module["asm"]["p"]).apply(null, arguments);
      });
    var _mid_song_get_time = (Module["_mid_song_get_time"] = function () {
      return (_mid_song_get_time = Module["_mid_song_get_time"] =
        Module["asm"]["q"]).apply(null, arguments);
    });
    var _mid_song_read_wave = (Module["_mid_song_read_wave"] = function () {
      return (_mid_song_read_wave = Module["_mid_song_read_wave"] =
        Module["asm"]["r"]).apply(null, arguments);
    });
    var _mid_song_set_volume = (Module["_mid_song_set_volume"] = function () {
      return (_mid_song_set_volume = Module["_mid_song_set_volume"] =
        Module["asm"]["s"]).apply(null, arguments);
    });
    var _mid_istream_open_mem = (Module["_mid_istream_open_mem"] = function () {
      return (_mid_istream_open_mem = Module["_mid_istream_open_mem"] =
        Module["asm"]["u"]).apply(null, arguments);
    });
    var _mid_istream_close = (Module["_mid_istream_close"] = function () {
      return (_mid_istream_close = Module["_mid_istream_close"] =
        Module["asm"]["v"]).apply(null, arguments);
    });
    var _mid_init_no_config = (Module["_mid_init_no_config"] = function () {
      return (_mid_init_no_config = Module["_mid_init_no_config"] =
        Module["asm"]["w"]).apply(null, arguments);
    });
    var _mid_exit = (Module["_mid_exit"] = function () {
      return (_mid_exit = Module["_mid_exit"] = Module["asm"]["x"]).apply(
        null,
        arguments
      );
    });
    var _mid_init = (Module["_mid_init"] = function () {
      return (_mid_init = Module["_mid_init"] = Module["asm"]["y"]).apply(
        null,
        arguments
      );
    });
    var _mid_song_load = (Module["_mid_song_load"] = function () {
      return (_mid_song_load = Module["_mid_song_load"] =
        Module["asm"]["z"]).apply(null, arguments);
    });
    var _mid_song_free = (Module["_mid_song_free"] = function () {
      return (_mid_song_free = Module["_mid_song_free"] =
        Module["asm"]["A"]).apply(null, arguments);
    });
    var _mid_get_version = (Module["_mid_get_version"] = function () {
      return (_mid_get_version = Module["_mid_get_version"] =
        Module["asm"]["B"]).apply(null, arguments);
    });
    var _mid_alloc_options = (Module["_mid_alloc_options"] = function () {
      return (_mid_alloc_options = Module["_mid_alloc_options"] =
        Module["asm"]["C"]).apply(null, arguments);
    });
    var _mid_get_load_request_count = (Module["_mid_get_load_request_count"] =
      function () {
        return (_mid_get_load_request_count = Module[
          "_mid_get_load_request_count"
        ] =
          Module["asm"]["D"]).apply(null, arguments);
      });
    var _mid_get_load_request = (Module["_mid_get_load_request"] = function () {
      return (_mid_get_load_request = Module["_mid_get_load_request"] =
        Module["asm"]["E"]).apply(null, arguments);
    });
    var ___errno_location = (Module["___errno_location"] = function () {
      return (___errno_location = Module["___errno_location"] =
        Module["asm"]["F"]).apply(null, arguments);
    });
    var stackSave = (Module["stackSave"] = function () {
      return (stackSave = Module["stackSave"] = Module["asm"]["G"]).apply(
        null,
        arguments
      );
    });
    var stackRestore = (Module["stackRestore"] = function () {
      return (stackRestore = Module["stackRestore"] = Module["asm"]["H"]).apply(
        null,
        arguments
      );
    });
    var stackAlloc = (Module["stackAlloc"] = function () {
      return (stackAlloc = Module["stackAlloc"] = Module["asm"]["I"]).apply(
        null,
        arguments
      );
    });
    Module["ccall"] = ccall;
    Module["FS"] = FS;
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun) run();
      if (!calledRun) dependenciesFulfilled = runCaller;
    };
    function run(args) {
      args = args || arguments_;
      if (runDependencies > 0) {
        return;
      }
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun) return;
        calledRun = true;
        Module["calledRun"] = true;
        if (ABORT) return;
        initRuntime();
        readyPromiseResolve(Module);
        if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
        postRun();
      }
      if (Module["setStatus"]) {
        Module["setStatus"]("Running...");
        setTimeout(function () {
          setTimeout(function () {
            Module["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function")
        Module["preInit"] = [Module["preInit"]];
      while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }
    run();

    return Libtimidity.ready;
  };
})();
if (typeof exports === "object" && typeof module === "object")
  module.exports = Libtimidity;
else if (typeof define === "function" && define["amd"])
  define([], function () {
    return Libtimidity;
  });
else if (typeof exports === "object") exports["Libtimidity"] = Libtimidity;
